const { Pet, BotConfig } = require("../database/models");
const logger = require("../utils/logger");

class PetMaintenanceService {
  constructor() {
    this.isRunning = false;
    this.maintenanceInterval = null;
    this.moodDecayInterval = 2 * 60 * 60 * 1000; // 2 hours
    this.energyRegenInterval = 1 * 60 * 60 * 1000; // 1 hour
  }

  /**
   * Start the pet maintenance service
   */
  async startMaintenance() {
    if (this.isRunning) {
      logger.info('Pet maintenance service is already running');
      return;
    }

    this.isRunning = true;
    logger.info('Starting pet maintenance service...');

    // Run initial maintenance
    await this.runMaintenance();

    // Set up periodic maintenance (every hour)
    this.maintenanceInterval = setInterval(async () => {
      await this.runMaintenance();
    }, 60 * 60 * 1000); // 1 hour

    logger.info('Pet maintenance service started successfully');
  }

  /**
   * Stop the pet maintenance service
   */
  stopMaintenance() {
    if (this.maintenanceInterval) {
      clearInterval(this.maintenanceInterval);
      this.maintenanceInterval = null;
    }
    this.isRunning = false;
    logger.info('Pet maintenance service stopped');
  }

  /**
   * Run comprehensive pet maintenance
   */
  async runMaintenance() {
    try {
      logger.info('Starting pet maintenance cycle...');
      
      // Get all guilds with pet system enabled
      const guildConfigs = await BotConfig.find({
        'petSystem.enabled': true
      });

      let totalPetsChecked = 0;
      let totalPetsUpdated = 0;

      for (const config of guildConfigs) {
        try {
          const { petsChecked, petsUpdated } = await this.maintainGuildPets(config);
          totalPetsChecked += petsChecked;
          totalPetsUpdated += petsUpdated;
        } catch (error) {
          logger.error(`Error maintaining pets in guild ${config.guildId}:`, error);
        }
      }

      logger.info(`Pet maintenance completed: ${totalPetsChecked} pets checked, ${totalPetsUpdated} pets updated`);
    } catch (error) {
      logger.error('Error running pet maintenance:', error);
    }
  }

  /**
   * Maintain pets for a specific guild
   */
  async maintainGuildPets(guildConfig) {
    const guildId = guildConfig.guildId;
    let petsChecked = 0;
    let petsUpdated = 0;

    try {
      // Get all active pets in this guild
      const activePets = await Pet.find({
        guildId: guildId,
        isActive: true
      });

      logger.info(`Maintaining ${activePets.length} pets in guild ${guildId}`);

      for (const pet of activePets) {
        try {
          const wasUpdated = await this.maintainPet(pet, guildConfig);
          if (wasUpdated) {
            petsUpdated++;
          }
          petsChecked++;
        } catch (error) {
          logger.error(`Error maintaining pet ${pet._id}:`, error);
        }
      }

      return { petsChecked, petsUpdated };
    } catch (error) {
      logger.error(`Error maintaining pets in guild ${guildId}:`, error);
      return { petsChecked: 0, petsUpdated: 0 };
    }
  }

  /**
   * Maintain a specific pet
   */
  async maintainPet(pet, guildConfig) {
    let wasUpdated = false;
    const now = new Date();

    try {
      // Calculate time since last activity
      const timeSinceLastActivity = now - pet.lastActivity;
      const hoursSinceActivity = timeSinceLastActivity / (60 * 60 * 1000);

      // Mood decay based on inactivity
      if (hoursSinceLastActivity >= 2) { // 2 hours
        const moodDecay = Math.floor(hoursSinceLastActivity / 2) * 5; // 5 points per 2 hours
        pet.stats.mood = Math.max(0, pet.stats.mood - moodDecay);
        wasUpdated = true;
        
        logger.debug(`Pet ${pet.name} mood decayed by ${moodDecay} points (${hoursSinceLastActivity.toFixed(1)}h inactive)`);
      }

      // Energy regeneration (slower when mood is low)
      if (hoursSinceLastActivity >= 1) { // 1 hour
        const energyRegen = Math.floor(hoursSinceLastActivity) * (pet.stats.mood > 50 ? 10 : 5); // 10/hour if happy, 5/hour if sad
        pet.stats.energy = Math.min(100, pet.stats.energy + energyRegen);
        wasUpdated = true;
        
        logger.debug(`Pet ${pet.name} energy regenerated by ${energyRegen} points`);
      }

      // Health regeneration (very slow, only when well cared for)
      if (hoursSinceLastActivity >= 4 && pet.stats.mood > 70 && pet.stats.energy > 70) {
        const healthRegen = Math.floor(hoursSinceLastActivity / 4) * 2; // 2 points per 4 hours
        pet.stats.health = Math.min(200, pet.stats.health + healthRegen);
        wasUpdated = true;
        
        logger.debug(`Pet ${pet.name} health regenerated by ${healthRegen} points`);
      }

      // Experience gain from being well cared for
      if (hoursSinceLastActivity >= 6 && pet.stats.mood > 80 && pet.stats.energy > 80) {
        const expGain = Math.floor(hoursSinceLastActivity / 6) * 5; // 5 XP per 6 hours
        await pet.addExperience(expGain);
        wasUpdated = true;
        
        logger.debug(`Pet ${pet.name} gained ${expGain} XP from good care`);
      }

      // Check for pet abandonment (30 days of inactivity)
      if (hoursSinceLastActivity >= 30 * 24) {
        pet.isActive = false;
        pet.status = 'abandoned';
        wasUpdated = true;
        
        logger.info(`Pet ${pet.name} marked as abandoned due to 30+ days of inactivity`);
      }

      // Update last maintenance time
      if (wasUpdated) {
        pet.lastMaintenance = now;
        await pet.save();
      }

      return wasUpdated;
    } catch (error) {
      logger.error(`Error maintaining pet ${pet._id}:`, error);
      return false;
    }
  }

  /**
   * Apply cooldown penalties for neglected pets
   */
  async applyCooldownPenalties(pet) {
    let penaltiesApplied = false;
    const now = new Date();

    try {
      // Check if pet has been neglected (mood < 20 for extended period)
      if (pet.stats.mood < 20) {
        const timeSinceLowMood = now - (pet.lastLowMood || pet.lastActivity);
        const hoursSinceLowMood = timeSinceLowMood / (60 * 60 * 1000);

        if (hoursSinceLowMood >= 24) { // 24 hours of low mood
          // Extend cooldowns
          if (pet.cooldowns.lastFed) {
            pet.cooldowns.lastFed = new Date(pet.cooldowns.lastFed.getTime() + 2 * 60 * 60 * 1000); // +2 hours
          }
          if (pet.cooldowns.lastTrained) {
            pet.cooldowns.lastTrained = new Date(pet.cooldowns.lastTrained.getTime() + 3 * 60 * 60 * 1000); // +3 hours
          }
          if (pet.cooldowns.lastPlayed) {
            pet.cooldowns.lastPlayed = new Date(pet.cooldowns.lastPlayed.getTime() + 1 * 60 * 60 * 1000); // +1 hour
          }

          pet.lastLowMood = now;
          penaltiesApplied = true;
          
          logger.info(`Applied cooldown penalties to neglected pet ${pet.name}`);
        }
      }

      return penaltiesApplied;
    } catch (error) {
      logger.error(`Error applying cooldown penalties to pet ${pet._id}:`, error);
      return false;
    }
  }

  /**
   * Get pet maintenance statistics
   */
  async getMaintenanceStats() {
    try {
      const totalPets = await Pet.countDocuments({ isActive: true });
      const happyPets = await Pet.countDocuments({ 
        isActive: true, 
        'stats.mood': { $gte: 80 } 
      });
      const sadPets = await Pet.countDocuments({ 
        isActive: true, 
        'stats.mood': { $lt: 30 } 
      });
      const abandonedPets = await Pet.countDocuments({ 
        isActive: false, 
        status: 'abandoned' 
      });

      return {
        totalPets,
        happyPets,
        sadPets,
        abandonedPets,
        isRunning: this.isRunning,
        maintenanceInterval: this.maintenanceInterval ? '1 hour' : null
      };
    } catch (error) {
      logger.error('Error getting maintenance stats:', error);
      return null;
    }
  }

  /**
   * Manual maintenance for a specific pet
   */
  async manualMaintenance(petId) {
    try {
      const pet = await Pet.findById(petId);
      if (!pet) {
        throw new Error('Pet not found');
      }

      const guildConfig = await BotConfig.findOne({ guildId: pet.guildId });
      if (!guildConfig) {
        throw new Error('Guild configuration not found');
      }

      const wasUpdated = await this.maintainPet(pet, guildConfig);
      const penaltiesApplied = await this.applyCooldownPenalties(pet);

      return {
        success: true,
        wasUpdated: wasUpdated || penaltiesApplied,
        pet: {
          id: pet._id,
          name: pet.name,
          mood: pet.stats.mood,
          energy: pet.stats.energy,
          health: pet.stats.health,
          lastMaintenance: pet.lastMaintenance
        }
      };
    } catch (error) {
      logger.error(`Error in manual pet maintenance for ${petId}:`, error);
      return {
        success: false,
        error: error.message
      };
    }
  }

  /**
   * Emergency pet care (restore mood and energy)
   */
  async emergencyCare(petId) {
    try {
      const pet = await Pet.findById(petId);
      if (!pet) {
        throw new Error('Pet not found');
      }

      // Restore pet to good condition
      pet.stats.mood = Math.min(100, pet.stats.mood + 50);
      pet.stats.energy = Math.min(100, pet.stats.energy + 50);
      pet.lastActivity = new Date();
      pet.lastMaintenance = new Date();

      await pet.save();

      logger.info(`Emergency care applied to pet ${pet.name}`);

      return {
        success: true,
        pet: {
          id: pet._id,
          name: pet.name,
          mood: pet.stats.mood,
          energy: pet.stats.energy,
          health: pet.stats.health
        }
      };
    } catch (error) {
      logger.error(`Error applying emergency care to pet ${petId}:`, error);
      return {
        success: false,
        error: error.message
      };
    }
  }
}

module.exports = PetMaintenanceService;
